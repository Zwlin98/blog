---
title: "My nvim config in 2025"
date: 2026-01-04T13:51:25+08:00
---

翻看 git log，2025 年的提交历史定格在 80 余次。借此机会，我打算对这一年的配置迭代与思考逻辑做一次总结复盘。

## 迁移至 blink.cmp

原有的补全系统虽然能用，但在处理数千行的大型代码文件时，毫秒之间的输入延迟仍会带来明显的顿挫感。基于社区对 `blink.cmp` 的推荐，以及我对该插件能力的乐观判断，我决定跟进。

迁移过程大致顺利，本打算拥抱 blink 生态全套方案并切换至 `blink.pairs`，但在实际使用一月后，发现针对部分边缘情况的处理, `nvim-autopairs` 依然更为稳定，因此最终选择回滚。目前的补全体验，确实更加的流畅。

##  LSP 简化

Neovim 0.11 引入了全新的 LSP 配置范式，`nvim-lspconfig` 的定位随之转型，逐渐回归为纯粹的配置中心，减少了对 LSP 加载逻辑的隐性干预。

我也是在更新 0.11 的第一时间重构了 LSP 配置。同时因为要写的语言变多，引入了更多的 language server 的配置。新的 LSP 配置方案确实更为简洁。在弃用 nvim-lspconfig 后，我只需将目标 Language Server 的配置复制到 lsp/ 目录下，并在代码中调用 enable 即可。

## 集成 AI 

今年尝试了 Avante.nvim、Aider、CodeCompanion.nvim 等诸多 AI 插件，也动手用 Lua 实现过基础的 AI Hover 功能（一键解释选中代码）。但在大浪淘沙后，最终常驻我配置的是 `claudecode.nvim`， 因为它最简单好用。

于我而言，编辑器内集成 AI 的核心价值并非单纯的代码生成，而在于对上下文的深度理解。AI 能够利用工具高效地理解 codebase。在接手陌生代码库时，AI 可以基于当前上下文解释复杂逻辑，而开发者只需辅以源码对照验证，其效率远超“盲人摸象”式的探索。它并非替代者，而是高效的结对编程伙伴。

## 做减法

今年虽尝试了不少新插件，但移除的数量更多。我清理了大量低频使用的插件，并删除了已不再使用的 neovide 兼容层。若一个插件提供 10 项功能而我仅需 2 项，剩余的 8 项便是负担。目前的选型策略更倾向于“功能专注”的小型插件。

此外，我开始倾向于编写原生 Lua 代码来替代部分简单的插件功能。通用插件为保证兼容性，往往包含大量防御性代码；而在个人配置中，边界情况清晰且可控。用数十行易于维护的代码实现特定需求，所带来的掌控感远胜于依赖第三方插件。

## DRY

Neovim 的魅力在于其高度的可编程性，这使得 DRY (Don't Repeat Yourself) 原则不仅适用于编码，也适用于工具链的优化。

*   **智能分屏 (`fzf-lua`)**：这是目前最高频使用的插件。我为其注入了 `smart vsplit` 逻辑：根据当前的窗口布局，自动判定是垂直分屏还是替换 Buffer，保持屏幕始终处于最佳分割状态。微小的改动在日均数十次的触发中，累积了巨大的体验提升。
*   **定制工具 (Ninja LSP)**：为优化公司内部 Lua 项目开发流程，编写了一个集成于 nvim 的轻量级 Language Server。该服务响应 `textDocument/definition` 请求，实现了内部项目特殊用法的精准跳转，显著提升了开发效率。
*   **远程编辑优化**：精简了 SSH 环境下的 OSC52 剪贴板配置，优化跨端复制体验；集成 kitty scrollback，实现了直接使用 Vim 模式编辑和复制终端输出内容。

还有其他小改动若干，包括 Lualine 的 Hostname 标识、相对路径文件名的一键获取、以及跨服务器的代码 Patch 导出命令等。这些不断优化的改动共同构成了 2025 年最契合我个人工作流的开发环境。